【问题描述】

数学老师给小明出了一道等差数列求和的题目。

但是粗心的小明忘记了一部分的数列，只记得其中 N 个整数。

现在给出这 N 个整数，小明想知道包含这 N 个整数的最短的等差数列有几项？

【输入格式】

输入的第一行包含一个整数 N。

第二行包含 N 个整数 A~1~, A~2~, · · · , A~N~。(注意 A~1~ ∼ A~N~ 并不一定是按等差数列中的顺序给出)

【输出格式】

输出一个整数表示答案。

【样例输入】

5
2 6 4 10 20

【样例输出】

10

【样例说明】

包含 2、6、4、10、20 的最短的等差数列是 2、4、6、8、10、12、14、16、18、20。

【评测用例规模与约定】

对于所有评测用例，2 ≤ N ≤ 100000，0 ≤ Ai ≤ 109。

## Ideas

因为 A1 ∼ AN 并不一定是按等差数列中的顺序给出，所以要先排一下序。

然后既然这是又给等差数列，那么我们当然首先要求出第 i 项和第 i + 1 项的差，构成一个 diff 数组。

之后我们再求出 diff 数组中所有数的最大公约数，这个最大公约数就是包含这 N 个整数的最短的等差数列的公差。

然后就是等差数列的内容了，我们用最后一项减去第一项，然后用差除以上面算出来的公差，得到的结果就是这个最短的等差数列中一共有多少个公差，然后再加上1，就是等差数列的长度。

最后要考虑一下边界情况，如果 diff 数组中所有数的最大公约数等于 0 呢，那就说明数组中存在相等的元素，此时我们直接返回 N 就可以了。

## Code

### Python

```python
def gcd(a, b):
	return gcd(b, a % b) if b else a


if __name__ == '__main__':
	n = int(input())
	nums = list(map(int, input().split(' ')))
	nums.sort()
	diff = [nums[i] - nums[i - 1] for i in range(1, n)]
	ans = gcd(diff[0], diff[1])
	for i in range(2, len(diff)):
		ans = gcd(ans, diff[i])
	print(((nums[-1] - nums[0]) // ans) + 1)
```