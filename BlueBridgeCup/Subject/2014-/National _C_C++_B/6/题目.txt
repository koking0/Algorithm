
标题：殖民地

    带着殖民扩张的野心，Pear和他的星际舰队登上X星球的某平原。为了评估这块土地的潜在价值，
Pear把它划分成了M*N格，每个格子上用一个整数（可正可负）表示它的价值。

    Pear要做的事很简单――选择一些格子，占领这些土地，通过建立围栏把它们和其它土地隔开。
对于M*N的格子，一共有(M+1)*N+M*(N+1)条围栏，即每个格子都有上下左右四个围栏；
不在边界上的围栏被相邻的两个格子公用。大概如下图【p1.png】所示。

    图中，蓝色的一段是围栏，属于格子1和2；红色的一段是围栏，属于格子3和4。
    
    每个格子有一个可正可负的收益，而建围栏的代价则一定是正的。

    你需要选择一些格子，然后选择一些围栏把它们围起来，
使得所有选择的格子和所有没被选的格子严格的被隔开。
选择的格子可以不连通，也可以有“洞”，
即一个连通块中间有一些格子没选。注意，若中间有“洞”，那么根据定义，“洞”和连通块也必须被隔开。

    Pear的目标很明确，花最小的代价，获得最大的收益。

【输入数据】
输入第一行两个正整数M N，表示行数和列数。
接下来M行，每行N个整数，构成矩阵A，A[i,j]表示第i行第j列格子的价值。
接下来M+1行，每行N个整数，构成矩阵B，B[i,j]表示第i行第j列上方的围栏建立代价。
特别的，B[M+1,j]表示第M行第j列下方的围栏建立代价。
接下来M行，每行N+1个整数，构成矩阵C，C[i,j]表示第i行第j列左方的围栏建立代价。
特别的，C[i,N+1]表示第i行第N列右方的围栏建立代价。

【输出数据】
一行。只有一个正整数，表示最大收益。

【输入样例1】
3 3
65 -6 -11
15 65 32
-8 5 66
4 1 6
7 3 11
23 21 22
5 25 22
26 1 1 13
16 3 3 4
6 3 1 2

程序应当输出：
123

【输入样例2】
6 6
72 2 -7 1 43 -12
74 74 -14 35 5 3
31 71 -12 70 38 66
40 -6 8 52 3 78
50 11 62 20 -6 61
76 55 67 28 -19 68
25 4 5 8 30 5
9 20 29 20 6 18
3 19 20 11 5 15
10 3 19 23 6 24
27 8 16 10 5 22
28 14 1 5 1 24
2 13 15 17 23 28
24 11 27 16 12 13 27
19 15 21 6 21 11 5
2 3 1 11 10 20 9
8 28 1 21 9 5 7
16 20 26 2 22 5 12
30 27 16 26 9 6 23

程序应当输出
870

【数据范围】
对于20%的数据，M,N<=4
对于50%的数据，M,N<=15
对于100%的数据，M,N<=200
A、B、C数组（所有的涉及到的格子、围栏输入数据）绝对值均不超过1000。根据题意，A数组可正可负，B、C数组均为正整数。


资源约定：
峰值内存消耗 < 256M
CPU消耗  < 3000ms


请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。

所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。

注意: main函数需要返回0
注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。
注意: 所有依赖的函数必须明确地在源文件中 #include <xxx>， 不能通过工程设置而省略常用头文件。

提交时，注意选择所期望的编译器类型。

