
生成树计数

给定一个 n*m 的格点图，包含 n 行 m 列共 n*m 个顶点，相邻的顶点之间有一条边。
【图1.png】给出了一个3*4的格点图的例子。


如果在图中删除部分顶点和其相邻的边，如上图删除第2行第3列和第3行第1列的顶点后，如【图2.png】所示。

图的生成树指包含图中的所有顶点和其中的一部分边，使得任意两个顶点之间都有由边构成的唯一路径。如果两个生成树包含有不同的边即被认为不同，则上图中共有31种不同的生成树，其中a边不选有10种，a边选有21种。
给出格点图中保留的顶点的信息，请计算该图一共有多少种不同的生成树。

【输入格式】
输入的第一行包含两个整数n, m，用空格分隔，表示格点图的行数和列数。
接下来n行，每行m个字母（中间没有分隔字符），每个字母必然是大写E或大写N，E表示对应的顶点存在，N表示对应的顶点不存在。保证存在至少一个顶点。

【输出格式】
输出一行，包含一个整数，表示生成树的个数。答案可能很大，你只需要计算答案除以1000000007的余数即可。

【样例输入】
3 4
EEEE
EENE
NEEE

【样例输出】
31

【数据规模与约定】
对于10%的数据，1<=n<=2。
对于30%的数据，1<=n<=3。
对于40%的数据，1<=n<=4。
对于50%的数据，1<=n<=5。
另有20%的数据，1<=n*m<=12。
另有10%的数据，1<=m<=15。
对于100%的数据，1<=n<=6，1<=m<=100000。

资源约定：
峰值内存消耗 < 256M
CPU消耗  < 4500ms

请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。

所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。

注意: main函数需要返回0
注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。
注意: 所有依赖的函数必须明确地在源文件中 #include <xxx>， 不能通过工程设置而省略常用头文件。

提交时，注意选择所期望的编译器类型。
